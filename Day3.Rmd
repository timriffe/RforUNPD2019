---
pagetitle: "Day 3"
title: | 
  | Introduction to R for Demographers
  | \vspace{1.5cm} \LARGE\emph{Workshop outline}
author: |
  | United Nations Population Division
  | 19-23 August, 2019
  | Tim Riffe
  | Max-Planck-Institute for Demographic Research
date: "21 August, 2019"
output:
  html_document:
    number_sections: yes
    toc: yes
params:
  output_dir: "../RforUNPD2019/docs"
header-includes:
- \usepackage{titling}
- \pretitle{\begin{center}\includegraphics[trim=0 0 0 8cm, width=6cm, ]{assets/MPIDR_square_color.pdf}\\[\bigskipamount]}
- \posttitle{\end{center}}
bibliography: bibliography.bib
---

<a href="https://github.com/timriffe/RforUNPD2019" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

In this lecture we will learn some basic programming tools. This may look rather foreign if you haven't seen code like this before. If you have, then you can know that conditional programming (`if`, `ifelse()`) works similar to anywhere else, as do `for` loops. I'll try to pull off the feat of introducing these concepts and making them relevant to you in a single session. 

# Conditional execution `if`

Conditional execution is performed in R using the command/function `if`. It works like this: 

1. One first **tests a condition**. 
2. **Only if** this condition is `TRUE`, the following code is executed.
3. If `FALSE`, then the following code chunk gets skipped. 

The main syntax is: 

``` {r, eval=FALSE}
if ( condition == TRUE ) {
	do.this
	}
```

Let's start with a very simple example
``` {r}
x <- rnorm(10)
if (mean(x) > 0){
  print("I'm feeling lucky")	
} 
```

Only if the condition is `TRUE`, does `R` print the result. The function `print()` is used to explicitly show an R-object in the console, like a character-string. The message `I'm feeling lucky` may or may not print to the console. It depends on the random numbers you got. In our case, we got 
``` {r}
mean(x)
```
I'll give more ad hoc examples of this basic idea in class.

The part that goes in the parenthesis after `if` just needs to evaluate to a single value of `TRUE` in order to execute the code afterwards.

``` {r}
if (mean(x) > 0) {
  print("I'm feeling lucky")
  print(x)
}
```
The curly brackets delimit the code that the `if` condition applies to, in much the same way es they demarcate the insides of a function. You can also place various lines of code inside the curly brackets.

In case you want to do something different if the condition is not met, you can add a second `else` clause. This would give an alternative code chunk to execute if the condition evaluates to `FALSE`:
``` {r}
if (mean(x) > 0){
  # Note the indentation in the brackets, 
  #  which is optional, but increases legibility
  print("I'm feeling lucky")
} else {
  print("Today is just not my day")
}
```

You can, of course, have more than one condition using the operators `&` (and) and `|` (or). 
``` {r}
random1 <- rnorm(1)
random2 <- rnorm(1)
if (random1 > 0 & random2 > 0) {
    print("Both random numbers are positive")
} else {
	print("At least one number is not positive")
}
```

Effectively,
``` {r}
random1; random2
```

We often use `if` statements to make code able to flexibly handle different cases. If the code is simple, you can also evaluate many such conditions at once using `ifelse()`, For instance, 
``` {r}
education <- c("Secondary", "Tertiary", "Secondary",
               "Secondary", "Tertiary", "Primary")
ifelse(education == "Tertiary", 1, 0)
```

Things can also get complicated by nesting `if` or `ifelse()` statements:
``` {r}
ifelse(education == "Tertiary", 2, 
	ifelse(education == "Secondary", 1, 0))
```

Sometimes we use `ifelse()` to recode variables if there aren't too many unique values to recode. Otherwise, use `case_when()` from the `tidyverse`, which is a better suited to this situation. This example comes from the `case_when()` documentation. NB, I remember playing this game as a kid. The game works like this: You sit in a circle and take turns counting in sequence, if the number you're on is evenly divisible by five, you say "fizz" instead of the number, and if it's evenly divisible by seven you say "buzz", and if it's divisble by both you say "fizz buzz". It has to be fast, but if anyone makes a mistake everyone has to start over.

```{r}
library(tidyverse)
x <- 1:50
case_when(
  x %% 35 == 0 ~ "fizz buzz",  # look we're using modulo again!! %%
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)       # this is the last 'else' instruction
)
```

Did you see what happened there? Aside from the logical testing, what kind of output did we produce? $x$ was an integer vector, and what we got back was a character vector. Inside vectors we can't mix data types, so `R` has to coerce to the lowest (human readable!) common denominator, which is a character string.

Other friends for logical testing are `all()` and `any()`
```{r}
(x <- rpois(10,10))
all(x > 0)
all(x > 5)
any(x >= 14) # at least one TRUE
```

Time out to find `if()` and friends used in the `DemoTools` package. NB: logical tests are a frequent source of bugs because sometimes we forget about how to handle certain conditions.

------------------------------------------------------------------------
**NOTE**

Bear in mind that `if` conditions can consist in any statement that has `TRUE` or `FALSE` as a result. The code is only executed if the answer is `TRUE`, unless an `else` condition is included.
------------------------------------------------------------------------

# Repetitive execution: `for`-loops

There are several commands available in `R` for repetitive execution, and now we will focus on `for` loops, i.e. iteration. In fact we did this without pointing it out in our tidy pipelines, for example in using `mutate()` after `group_by()`. The kind of `for`-loop construction used in `R` is common in other languages. It is often considered to be the most legible kind of iteration for this reason. The basic form looks like this:

``` {r eval=FALSE, cache=TRUE}
for (i in values) {
  execute.this
}
```

The parameter `i` assumes the value of each element of `values` in succession. In the first iteration, `i` takes on the first value of `values` in the first loop and executes `execute.this`. In the second run, the second value is taken from `values` and so on until the last value is taken from `values` and `execute.this` is executed the last time. You can name `i` anything you want, and `values` can be any valid vector (not necessarily integer numbers). The code chunk in curly brackets can be big or small.

Here are some examples for clarification:
``` {r}
countries <- c("AUT", "BEL", "DEU", "NLD", "GBR", "USA")
for (i in countries) {
  print(i)
}
for (i in 2:4) {
  print(countries[i+1])
}
```

Let's say you have a vector of random numbers, and you want to compute the cumulative sum. A `for`-loop could be used to perform this task.

``` {r}
vec <- sort(runif(20))
vec
# Create an object with the first value of vec
cumSum <- rep(0, 20)
# Store the cumulative sum
for (i in 1:length(vec)) {
  cumSum[i] <- sum(vec[1:i])
}
cumSum
```

Just so you get the idea... You've seen the `cumsum()` function already, and it's actually much more efficient.
``` {r}
cumsum(vec)
```
# Combining `if` and `for`-loops

The next function finds the Collatz number of a positive integer, due to the still-unproven Collatz conjecture, which (paraphrasing here) states that all positive integers can be reduced to 1 by following this iterative process: if the present iteration of the number is even, then divide by two, otherwise multiply by 3 and add 1 to it. Repeat as necessary until the number is reduced to 1. The number of steps it takes to get there is the integer's Collatz number. These have funny patterns... that are hard to see without visualizing them... Let's turn those words into a function together in class.
```{r, eval = FALSE}
Collatz <- function(...){
	...
}
```

```{r, eval = FALSE, echo = FALSE}
# due to Collatz Conjecture. 
Collatz <- function(number, maxit = 1e5){
	number  <- as.integer(number)
	Cnumber <- 0 
	for (fake.iterator in 1:maxit){ 
		if (number != 1){ 
			# first increment our counter
			Cnumber <- Cnumber + 1    
			if (number %% 2 == 0){
				number <- number / 2
			} else {
				number <- number * 3 + 1
			}
		} else {
			# otherwise it must equal 1!
			break
		}
	}
	Cnumber
}
```



# References 

